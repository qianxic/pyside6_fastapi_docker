# 遥感影像变化检测系统软件设计文档

## 一、系统架构设计

### 1.1 整体架构
```
┌─────────────────────────────────────────────────────────────┐
│                    遥感影像变化检测系统 V1.0                    │
├─────────────────────────────────────────────────────────────┤
│                       前端应用 (PySide6)                      │
│  ┌─────────────────────────────────────────────────────┐    │
│  │  图像显示与交互模块                                │    │
│  │  批量处理管理                                       │    │
│  │  渔网分割功能                                       │    │
│  │  主题切换系统                                       │    │
│  │  API通信模块 (与后端容器交互)                       │    │
│  └─────────────────────────────────────────────────────┘    │
│                              │                              │
│                              ▼                              │
│                    ┌───────────────────────┐                │
│                    │  Docker容器化后端服务  │                │
│                    │  ┌─────────────────┐  │                │
│                    │  │  FastAPI服务    │  │                │
│                    │  │  AI模型推理     │  │                │
│                    │  │  (PyTorch+X3D)  │  │                │
│                    │  │  地理空间处理   │  │                │
│                    │  │  (GDAL+GeoPandas)│ │                │
│                    │  └─────────────────┘  │                │
│                    │  GPU加速支持          │                │
│                    └───────────────────────┘                │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 技术架构
- **前端技术栈**：PySide6 + Qt框架 + 响应式布局
- **后端技术栈**：Python + FastAPI + PyTorch + CUDA
- **深度学习框架**：PyTorch 2.8.0 + X3D模型
- **地理信息处理**：GDAL + GeoPandas + Rasterio
- **容器化部署**：Docker + Docker Compose + NVIDIA Docker

## 二、核心模块设计

### 2.1 变化检测引擎模块

#### 2.1.1 功能描述
变化检测引擎是系统的核心模块，负责执行遥感影像的变化检测任务。支持单图像和栅格影像两种模式的变化检测。

#### 2.1.2 技术实现
```python
class ChangeDetectionEngine:
    def __init__(self):
        self.model = X3DChangeDetectionModel()
        self.preprocessor = ImagePreprocessor()
        self.postprocessor = ResultPostprocessor()
    
    def detect_single_image(self, image1, image2):
        """单图像变化检测"""
        # 图像预处理
        processed_img1 = self.preprocessor.process(image1)
        processed_img2 = self.preprocessor.process(image2)
        
        # 模型推理
        result = self.model.inference(processed_img1, processed_img2)
        
        # 后处理
        final_result = self.postprocessor.process(result)
        return final_result
    
    def detect_single_raster(self, raster1, raster2):
        """栅格影像变化检测"""
        # 地理信息保持
        geospatial_data = self.preprocessor.process_geospatial(raster1, raster2)
        
        # 变化检测
        result = self.detect_single_image(geospatial_data['img1'], geospatial_data['img2'])
        
        # 地理信息恢复
        final_result = self.postprocessor.restore_geospatial(result, geospatial_data['metadata'])
        return final_result
```

### 2.2 图像处理模块

#### 2.2.1 功能描述
图像处理模块负责处理各种格式的影像数据，包括图像预处理、格式转换、地理信息保持等功能。

#### 2.2.2 技术实现
```python
class ImageProcessor:
    def __init__(self):
        self.supported_formats = {
            'image': ['PNG', 'JPG', 'JPEG'],
            'raster': ['TIFF', 'GeoTIFF', 'IMG', 'DEM', 'HGT']
        }
    
    def load_image(self, file_path):
        """加载图像文件"""
        format_type = self.detect_format(file_path)
        if format_type == 'image':
            return self.load_regular_image(file_path)
        elif format_type == 'raster':
            return self.load_raster_image(file_path)
    
    def load_raster_image(self, file_path):
        """加载栅格影像"""
        import rasterio
        with rasterio.open(file_path) as src:
            data = src.read()
            metadata = {
                'crs': src.crs,
                'transform': src.transform,
                'bounds': src.bounds
            }
        return {'data': data, 'metadata': metadata}
```

### 2.3 用户界面模块

#### 2.3.1 功能描述
用户界面模块提供直观的操作界面，支持图像显示、交互操作、主题切换等功能。

#### 2.3.2 技术实现
```python
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setup_ui()
        self.setup_connections()
    
    def setup_ui(self):
        """设置用户界面"""
        # 创建四区域布局
        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        
        # 前时相显示区域
        self.before_image_widget = ImageDisplayWidget("前时相影像")
        
        # 后时相显示区域
        self.after_image_widget = ImageDisplayWidget("后时相影像")
        
        # 结果显示区域
        self.result_widget = ImageDisplayWidget("检测结果")
        
        # 日志显示区域
        self.log_widget = LogDisplayWidget()
        
        # 设置布局
        self.setup_layout()
    
    def setup_layout(self):
        """设置四区域布局"""
        layout = QGridLayout()
        layout.addWidget(self.before_image_widget, 0, 0)
        layout.addWidget(self.after_image_widget, 0, 1)
        layout.addWidget(self.result_widget, 1, 0)
        layout.addWidget(self.log_widget, 1, 1)
        self.central_widget.setLayout(layout)
```

### 2.4 批量处理模块

#### 2.4.1 功能描述
批量处理模块支持大规模影像对的批量变化检测，提供任务队列管理和进度监控功能。

#### 2.4.2 技术实现
```python
class BatchProcessor:
    def __init__(self):
        self.task_queue = Queue()
        self.result_queue = Queue()
        self.workers = []
    
    def add_batch_task(self, input_dir, output_dir, task_type):
        """添加批量任务"""
        task = {
            'input_dir': input_dir,
            'output_dir': output_dir,
            'task_type': task_type,
            'status': 'pending'
        }
        self.task_queue.put(task)
    
    def start_processing(self, num_workers=4):
        """启动批量处理"""
        for i in range(num_workers):
            worker = BatchWorker(self.task_queue, self.result_queue)
            worker.start()
            self.workers.append(worker)
    
    def monitor_progress(self):
        """监控处理进度"""
        while not self.task_queue.empty():
            completed = self.result_queue.qsize()
            total = self.task_queue.qsize() + completed
            progress = (completed / total) * 100
            yield progress
```

## 三、数据库设计

### 3.1 数据存储结构
```python
# 任务记录表
class TaskRecord:
    id: int
    task_type: str  # 'single_image', 'single_raster', 'batch_image', 'batch_raster'
    input_paths: List[str]
    output_path: str
    status: str  # 'pending', 'processing', 'completed', 'failed'
    created_at: datetime
    completed_at: datetime
    error_message: str

# 处理结果表
class ProcessingResult:
    id: int
    task_id: int
    result_type: str  # 'change_mask', 'statistics', 'vector_data'
    result_path: str
    metadata: dict
    created_at: datetime
```

## 四、API接口设计

### 4.1 RESTful API接口

#### 4.1.1 单图像变化检测
```http
POST /detect/single_image
Content-Type: multipart/form-data

Parameters:
- image1: 前时相图像文件
- image2: 后时相图像文件

Response:
{
    "status": "success",
    "result_path": "/path/to/result.png",
    "processing_time": 25.6,
    "change_statistics": {
        "changed_pixels": 12345,
        "change_percentage": 15.2
    }
}
```

#### 4.1.2 栅格影像变化检测
```http
POST /detect/single_raster
Content-Type: multipart/form-data

Parameters:
- raster1: 前时相栅格文件
- raster2: 后时相栅格文件

Response:
{
    "status": "success",
    "result_path": "/path/to/result.tif",
    "vector_path": "/path/to/result.shp",
    "processing_time": 45.2,
    "geospatial_info": {
        "crs": "EPSG:4326",
        "bounds": [min_x, min_y, max_x, max_y]
    }
}
```

## 五、性能优化设计

### 5.1 GPU加速优化
```python
class GPUOptimizer:
    def __init__(self):
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    
    def optimize_model(self, model):
        """模型GPU优化"""
        model = model.to(self.device)
        if torch.cuda.is_available():
            model = torch.nn.DataParallel(model)
        return model
    
    def optimize_batch_processing(self, batch_size=8):
        """批量处理优化"""
        return {
            'batch_size': batch_size,
            'num_workers': 4,
            'pin_memory': True
        }
```

### 5.2 内存管理优化
```python
class MemoryManager:
    def __init__(self):
        self.memory_threshold = 0.8  # 80%内存使用率阈值
    
    def check_memory_usage(self):
        """检查内存使用情况"""
        import psutil
        memory_percent = psutil.virtual_memory().percent / 100
        return memory_percent < self.memory_threshold
    
    def cleanup_memory(self):
        """清理内存"""
        import gc
        gc.collect()
        if torch.cuda.is_available():
            torch.cuda.empty_cache()
```

## 六、安全设计

### 6.1 数据安全
- 文件上传验证：文件格式、大小限制
- 数据加密：敏感数据传输加密
- 访问控制：API访问权限管理

### 6.2 系统安全
- 输入验证：防止恶意输入
- 错误处理：统一异常处理机制
- 日志记录：操作日志和安全审计

## 七、部署设计

### 7.1 容器化部署
```yaml
# docker-compose.yml
version: '3.8'
services:
  change-detection-api:
    build: .
    ports:
      - "8000:8000"
    volumes:
      - ./data:/app/data
    environment:
      - CUDA_VISIBLE_DEVICES=0
    deploy:
      resources:
        reservations:
          devices:
            - driver: nvidia
              count: 1
              capabilities: [gpu]
```

### 7.2 环境配置
```python
# config.py
class Config:
    # API配置
    API_HOST = "0.0.0.0"
    API_PORT = 8000
    
    # 模型配置
    MODEL_PATH = "/app/models/x3d_model.pth"
    DEVICE = "cuda"
    
    # 数据处理配置
    MAX_FILE_SIZE = 100 * 1024 * 1024  # 100MB
    SUPPORTED_FORMATS = ["png", "jpg", "tiff", "geotiff"]
    
    # 存储配置
    UPLOAD_DIR = "/app/uploads"
    RESULT_DIR = "/app/results"
```

---

**文档版本**：V1.0
**创建日期**：2025年8月31日
**更新日期**：2025年8月31日
